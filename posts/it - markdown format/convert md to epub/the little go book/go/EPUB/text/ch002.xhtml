<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch002.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="introduction" class="level1" data-number="2">
<h1 data-number="2">Introduction</h1>
<p>I’ve always had a love-hate relationship when it comes to learning new languages. On the one hand, languages are so fundamental to what we do, that even small changes can have measurable impact. That <em>aha</em> moment when something clicks can have a lasting effect on how you program and can redefine your expectations of other languages. On the downside, language design is fairly incremental. Learning new keywords, type system, coding style as well as new libraries, communities and paradigms is a lot of work that seems hard to justify. Compared to everything else we have to learn, new languages often feel like a poor investment of our time.</p>
<p>That said, we <em>have</em> to move forward. We <em>have</em> to be willing to take incremental steps because, again, languages are the foundation of what we do. Though the changes are often incremental, they tend to have a wide scope and they impact productivity, readability, performance, testability, dependency management, error handling, documentation, profiling, communities, standard libraries, and so on. Is there a positive way to say <em>death by a thousand cuts</em>?</p>
<p>That leaves us with an important question: <strong>why Go?</strong> For me, there are two compelling reasons. The first is that it’s a relatively simple language with a relatively simple standard library. In a lot of ways, the incremental nature of Go is to simplify some of the complexity we’ve seen being added to languages over the last couple of decades. The other reason is that for many developers, it will complement your existing arsenal.</p>
<p>Go was built as a system language (e.g., operating systems, device drivers) and thus aimed at C and C++ developers. According to the Go team, and which is certainly true of me, application developers, not system developers, have become the primary Go users. Why? I can’t speak authoritatively for system developers, but for those of us building websites, services, desktop applications and the like, it partially comes down to the emerging need for a class of systems that sit somewhere in between low-level system applications and higher-level applications.</p>
<p>Maybe it’s a messaging, caching, computational-heavy data analysis, command line interface, logging or monitoring. I don’t know what label to give it, but over the course of my career, as systems continue to grow in complexity and as concurrency frequently measures in the tens of thousands, there’s clearly been a growing need for custom infrastructure-type systems. You <em>can</em> build such systems with Ruby or Python or something else (and many people do), but these types of systems can benefit from a more rigid type system and greater performance. Similarly, you <em>can</em> use Go to build websites (and many people do), but I still prefer, by a wide margin, the expressiveness of Node or Ruby for such systems.</p>
<p>There are other areas where Go excels. For example, there are no dependencies when running a compiled Go program. You don’t have to worry if your users have Ruby or the JVM installed, and if so, what version. For this reason, Go is becoming increasingly popular as a language for command-line interface programs and other types of utility programs you need to distribute (e.g., a log collector).</p>
<p>Put plainly, learning Go is an efficient use of your time. You won’t have to spend long hours learning or even mastering Go, and you’ll end up with something practical from your effort.</p>
<section id="a-note-from-the-author" class="level2" data-number="2.1">
<h2 data-number="2.1">A Note from the Author</h2>
<p>I’ve hesitated writing this book for a couple reasons. The first is that Go’s own documentation, in particular <a href="https://golang.org/doc/effective_go.html">Effective Go</a>, is solid.</p>
<p>The other is my discomfort at writing a book about a language. When I wrote The Little MongoDB Book, it was safe to assume most readers understood the basics of relational database and modeling. With The Little Redis Book, you could assume a familiarity with a key value store and take it from there.</p>
<p>As I think about the paragraphs and chapters that lay ahead, I know that I won’t be able to make those same assumptions. How much time do you spend talking about interfaces knowing that for some, the concept will be new, while others won’t need much more than <em>Go has interfaces</em>? Ultimately, I take comfort in knowing that you’ll let me know if some parts are too shallow or others too detailed. Consider that the price of this book.</p>
</section>
</section>
</body>
</html>
