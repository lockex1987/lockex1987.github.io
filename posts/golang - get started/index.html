<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="date" content="2021-05-12 11:56:00">
    <meta name="description" content="Book">
    <title>Lập trình Go</title>
    <link rel="icon" href="../../images/favicon.png">
    <link rel="stylesheet" href="../../css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Merriweather:900" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Hind+Guntur:600" rel="stylesheet">
    <link rel="stylesheet" href="css/cover.css">
    <link rel="stylesheet" href="css/book_conventions.css">
  </head>
  <body>
    <article>
      <div class="mb-3">
        <div class="book-cover">
          <div class="title-small"> Lập trình </div>
          <div class="title"> Go </div>
          <div class="subtitle"> Simple is better than smart </div>
          <div class="image"> <img src="images/cover-4.jpg"> </div>
          <div class="author"> Nguyễn Văn Huyên </div>
          <div class="publisher"> <img src="images/packt-icon.jpg">
            <div class="name"> Packt </div>
            <div class="website"> www.packt.com </div>
          </div>
        </div>
      </div>
      <p>Code ngắn gọn, dạng snippet, có ảnh minh họa.</p>
      <p>Ghi chép lại hàng ngày. Sau một năm, khi số lượng và chất lượng đã OK
        thì xuất bản epub book, dạng handbook như Flavio Copes.</p>
      <p>Học từ dễ đến khó. Không đâm đầu vào luôn Goroutine.</p>
      <p>Học ngôn ngữ mới, hiện đại: có logging, linting, testing.</p>
      <ul data-toc="">
        <!-- TOC ở đây -->
      </ul>
      <h3>Convention trong sách</h3>
      <p>Câu lệnh có nền xám:</p>
      <pre class="command">cmd</pre>
      <p>Kết quả câu lệnh có nền đen và chữ trắng:</p>
      <pre class="output">lorem ipsum</pre>
      <p>Mã nguồn có border trái:</p>
      <pre class="code-block"><code class="gox">package main

import "fmt"

func main() {

}</code></pre>
      <p>Chú ý có khung border và nền xanh:</p>
      <div class="note">Lorem ipsum</div>
      <h3>Tác giả</h3>
      <p>Nguyễn Văn Huyên</p>
      <p>lockex1987.github.io</p>
      <p>Sách này dành tặng cho Nguyễn Anh Tuấn - thằng bé chạy theo quả bóng.</p>
      <h3>Cài đặt</h3>
      <p>Sử dụng script.</p>
      <p>Theo hướng dẫn ở trang chủ, sử dụng lệnh sau:</p>
      <pre>curl -fsSL https://deno.land/x/install/install.sh | sh</pre>
      <p>Tình hình là ở Việt Nam bị đứt cáp. Nếu cài đặt qua mạng như hướng dẫn
        ở trang chủ thì bước download file từ GitHub rất là chậm. Ngoài ra, thực
        tế có thể bạn cần cài cho một server nào đó mà server đó lại không có
        kết nối Internet. Do đó hãy cài offline nào.</p>
      <p>Đầu tiên, hãy download file <code>deno-x86_64-unknown-linux-gnu.zip</code>
        từ địa chỉ sau:</p>
      <p> <a href="https://github.com/denoland/deno/releases" target="_blank">Releases
          · denoland/deno</a></p>
      <p>Tiếp theo, để file <code>install.sh</code> ở ngang với file vừa
        download, rồi thực hiện lệnh:</p>
      <pre>sh install.sh</pre>
      <p>Nội dung file <code>install.sh</code> như sau:</p>
      <pre>#!/bin/sh

deno_install="${DENO_INSTALL:-$HOME/.deno}"
bin_dir="$deno_install/bin"
exe="$bin_dir/deno"

if [ ! -d "$bin_dir" ]; then
&nbsp; &nbsp; mkdir -p "$bin_dir"
fi

cp deno-x86_64-unknown-linux-gnu.zip "$exe.zip"

cd "$bin_dir"
unzip -o "$exe.zip"
chmod +x "$exe"
rm "$exe.zip"</pre>
      <p>Sau đó, sửa file <code>~/.bashrc</code>, thêm đoạn sau:</p>
      <pre>DENO_INSTALL="$HOME/.deno"
PATH="$DENO_INSTALL/bin:$PATH"

export DENO_INSTALL
export PATH</pre>
      <p>Kiểm tra:</p>
      <pre>deno --version</pre>
      <p>Nếu mà các biến môi trường vẫn chưa được hiệu lực, bạn không cần login
        lại mà có thể làm như sau:</p>
      <pre>source ~/.bashrc</pre>
      <p>Deno lưu các file cache ở thư mục <code>~/.cache/deno</code>.</p>
      <h4>Windows</h4>
      <p>Download file msi từ địa chỉ sau:</p>
      <p><a href="https://golang.org/dl/" target="_blank">https://golang.org/dl/</a></p>
      <p>Sau đó cài đặt như chương trình bình thường. Trình cài đặt sẽ tự thêm
        các đường dẫn <code>C:\Program Files\Go\bin</code> và <code>C:\Users\&lt;tên
          user&gt;\go\bin</code> vào biến môi trường <code>PATH</code>. Bạn có
        thể thực hiện các lệnh: <code>go</code>, <code>gofmt</code>, <code>go-outline</code>,
        <code>gopls</code>,...</p>
      <p>Kiểm tra việc cài đặt có thành công không:</p>
      <pre class="command">go version</pre>
      <p>Kết quả có dạng:</p>
      <pre class="output">go version go1.16.3 windows/amd64</pre>
      <h4>Linux</h4>
      <p>Thực hiện các lệnh sau, thay GOVERSION bằng giá trị tương ứng bạn muốn:</p>
      <pre class="command">GOVERSION="go1.16.4"

curl -O https://golang.org/dl/$GOVERSION.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf $GOVERSION.linux-amd64.tar.gz
# sudo tar -xvf $GOVERSION.linux-amd64.tar.gz
# sudo rm -rf /usr/local/go
# sudo mv go /usr/local
# sudo rm $GOVERSION.linux-amd64.tar.gz

echo 'export PATH=$PATH:/usr/local/go/bin' &gt;&gt; ~/.profile
# echo 'export GOPATH=$HOME/go' &gt;&gt; ~/.profile
# echo 'export PATH=$PATH:$GOPATH/bin' &gt;&gt; ~/.profile

source ~/.profile
</pre>
      <p>Ảnh</p>
      <h3>Chương trình đầu tiên</h3>
      <p>Soạn thảo file <code>hello.go</code> với nội dung sau:</p>
      <div class="source-file">hello.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

func main() {
	fmt.Println("Xin chào thế giới")
}</code></pre>
      <p>Thực hiện:</p>
      <pre>go run hello.go</pre>
      <p>Build:</p>
      <pre>go build hello.go</pre>
      <p>Lệnh trên sẽ tạo file <code>hello.exe</code> (trên Windows) và file <code>hello</code>
        (trên Linux).</p>
      <p>Chạy file thực thi trên Windows:</p>
      <pre>hello.exe</pre>
      <p>Trên Linux:</p>
      <pre>./hello</pre>
      <h3>VSCode extension</h3>
      <p>Tôi sử dụng trình soạn thảo VSCode và extension sau:</p>
      <p><a href="https://marketplace.visualstudio.com/items?itemName=golang.go"

          target="_blank">Go - Visual Studio Marketplace</a></p>
      <p>Highlight syntax</p>
      <p>Tự động format code</p>
      <p>Tự động thêm import</p>
      <h3>Tham số dòng lệnh</h3>
      <p>Sử dụng os.Args.</p>
      <div class="source-file">arguments.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep string
	for i := 1; i &lt; len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = ","
	}
	fmt.Println(s)
}</code></pre>
      <p>Thực thi:</p>
      <pre class="output">$ go run arguments.go ABC DEF
ABC,DEF</pre>
      <h3>Comment</h3>
      <p>Có hai dạng comment như các ngôn ngữ khác:</p>
      <p>Convention comment là gì? Khai báo đầu file, hàm?</p>
      <p><code>// Comment dòng </code></p>
      <p><code>/* Comment khối */ </code></p>
      <h3>Biến</h3>
      <div class="source-file">variables.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

func main() {
	// Khai báo, sau đó gán giá trị
	var s1 string
	s1 = "s1"

	// Vừa khai báo vừa khởi tạo
	var s2 string = "s2"

	// Có thể bỏ qua kiểu dữ liệu
	var s3 = "s3"

	// Có thể bỏ qua từ khóa var
	s4 := "s4"

	// Lần sau gán lại giá trị cho biến,
	// chúng ta chỉ sử dụng =, không sử dụng :=
	s4 = "s4 updated"

	fmt.Println(s1)
	fmt.Println(s2)
	fmt.Println(s3)
	fmt.Println(s4)
}</code></pre>
      <br>
      <h3>Hằng</h3>
      <p>Sử dụng từ khóa <code>const</code>.</p>
      <div class="source-file">constants.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

const boilingF = 212.0

func main() {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("Boiling point = %g°F or %g°C\n", f, c)
}</code></pre>
      <p>Phạm vi của hằng?</p>
      <h3>Từ khóa</h3>
      <p>Và hằng, tên kiểu dữ liệu, hàm built-in.</p>
      <p>Go có 25 từ khóa:</p>
      <table class="table table-responsive-md">
        <tbody>
          <tr>
            <td class="border-top-0"><code>break</code> (dùng ở khối for)</td>
            <td class="border-top-0"><code>default</code> (dùng ở khối switch)</td>
            <td class="border-top-0"><code>func</code> (dùng để khai báo hàm)</td>
            <td class="border-top-0"><code>interface</code> (khai báo kiểu
              interface)</td>
            <td class="border-top-0"><code>select</code><br>
              (goroutine)</td>
          </tr>
          <tr>
            <td><code>case</code> (dùng ở khối switch)</td>
            <td><code>defer</code> (thực hiện câu lệnh sau khi hàm kết thúc)</td>
            <td><code>go</code><br>
              (chạy goroutine)</td>
            <td><code>map</code> (kiểu dữ liệu map)</td>
            <td><code>struct</code> (kiểu dữ liệu struct)</td>
          </tr>
          <tr>
            <td><code>chan</code><br>
              (channel)</td>
            <td><code>else</code> (khối if else)</td>
            <td><code>goto</code><br>
              (nhảy tới label)</td>
            <td><code>package</code> (khai báo package đầu file)</td>
            <td><code>switch</code> (dùng ở khối switch)</td>
          </tr>
          <tr>
            <td><code>const</code> (khai báo hằng số)</td>
            <td><code>fallthrough</code> (dùng ở khối switch)</td>
            <td><code>if</code> (dùng ở khối if else)</td>
            <td><code>range</code> (rất hay dùng với khối for)</td>
            <td><code>type</code> (định nghĩa kiểu dữ liệu mới)</td>
          </tr>
          <tr>
            <td><code>continue</code> (sử dụng ở khối for)</td>
            <td><code>for</code> (sử dụng ở khối for)</td>
            <td><code>import</code> (import các package phụ thuộc)</td>
            <td><code>return</code> (trả về kết thúc hàm)</td>
            <td><code>var</code> (khai báo biến)</td>
          </tr>
        </tbody>
      </table>
      <p>Các hằng số:</p>
      <p><code>true</code>, <code>false</code>, iota, <code>nil</code></p>
      <p>Các kiểu dữ liệu:</p>
      <p><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>,
        <code>int64</code> (int tương đương ?)</p>
      <p><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>,
        <code>uint64</code>, <code>uintptr</code> (uint tương đương ?)</p>
      <p><code>float32</code>, <code>float64</code></p>
      <p>complex64, complex128</p>
      <p><code>bool</code></p>
      <p>byte</p>
      <p>rune</p>
      <p><code>string</code></p>
      <p>error</p>
      <p>Các hàm:</p>
      <p>make:</p>
      <p><code>len</code></p>
      <p>cap</p>
      <p><code>new</code>: Tạo mới pointer</p>
      <p>append:</p>
      <p>copy:</p>
      <p><code>close</code>: Đóng channel</p>
      <p>delete:</p>
      <p>complex:</p>
      <p>real:</p>
      <p>imag:</p>
      <p>panic:</p>
      <p>recover:</p>
      <h3>Toán tử</h3>
      <p>Go cũng có các toán tử như các ngôn ngữ khác:</p>
      <p><code>+</code> (cộng), <code>-</code> (trừ), <code>*</code> (nhân), <code>/</code>
        (chia),</p>
      <p><code>+=</code> (cộng thêm vào), <code>-=</code> (từ đi), <code>*=</code>
        (nhân vào), <code>/=</code> (chia đi),</p>
      <p><code>=</code> (gán), <code>:=</code> (khai báo và khởi tạo),</p>
      <p><code>++</code> (tăng), <code>--</code> (giảm)</p>
      <h3>Hàm</h3>
      <p>Sử dụng từ khóa <code>func</code>.</p>
      <p>Cấu trúc:</p>
      <pre>func name(parameter-list) (result-list) {<br>   body<br>}</pre>
      <p>Hàm cũng có thể gán cho biến.</p>
      <p>Có hàm anonymous.</p>
      <p>Hàm variadic, số tham số tùy biến.</p>
      <p>Hàm có thể được <code>defer</code>.</p>
      <div class="source-file">functions.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func fToC(f float64) float64 {
	return (f - 32) * 5 / 9
}

/**
 * Hàm có thể trả về nhiều giá trị.
 */
func threeRandom() (int, int, int) {
	rand.Seed(time.Now().UnixNano())
	x := rand.Intn(10)
	y := rand.Intn(10)
	z := rand.Intn(10)
	return x, y, z
}

func main() {
	const freezingF = 32.0
	const boilingF = 212.0
	fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF))
	fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))

	r1, r2, r3 := threeRandom()
	fmt.Println(r1, r2, r3)
}</code></pre>
      <h3>Gán tuple</h3>
      <div class="source-file">tuple-assignment.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

/**
 * Ước số chung lớn nhất (Greatest Common Divisor).
 */
func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}
	return x
}

/**
 * Fibonacci.
 */
func fib(n int) int {
	x, y := 0, 1
	for i := 0; i &lt; n; i++ {
		x, y = y, x+y
	}
	return x
}

func main() {
	fmt.Println("Tuple")
}</code></pre>
      <h3>Cấu trúc điều khiển</h3>
      <h4>if else</h4>
      <p>Không cần dấu mở ngoặc và đóng ngoặc. Nếu thêm vào thì <code>golint</code>
        cũng tự động bỏ đi.</p>
      <div class="source-file">condition.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	num := 5 + rand.Intn(10)
	var desc string
	if num &gt; 0 {
		desc = "positive"
	} else if num == 0 {
		desc = "zero"
	} else {
		desc = "negative"
	}
	fmt.Println("The number", num, "is", desc)
}</code></pre>
      <h4>switch</h4>
      <p>Không cần từ khóa <code>break</code> ở mỗi block.</p>
      <div class="source-file">switch.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"runtime"
)

func main() {
	os := runtime.GOOS
	switch os {
	case "windows":
		fmt.Println("Windows")
	case "darwin":
		fmt.Println("Mac")
	case "linux":
		fmt.Println("Linux")
	default:
		fmt.Println(os)
	}
}</code></pre>
      <p>Có thêm từ khóa <code>fallthrough</code> để. </p>
      <h4>for</h4>
      <p>Cấu trúc chung:</p>
      <pre>for initialization; condition; post {<br>}</pre>
      <p>Có thể giản lược để thay thế các vòng lặp while, do-while trong các
        ngôn ngữ khác:</p>
      <pre>// Vòng lặp "while"<br>for condition {<br>}<br><br>// Vòng lặp vô hạn<br>for {<br>}</pre>
      <p>Có thể sử dụng <code>break</code> và <code>continue</code> trong vòng
        lặp như các ngôn ngữ khác.</p>
      <h5>Từ khóa range</h5>
      <p>Cấu trúc:</p>
      <pre>for first, second := range x {<br>}</pre>
      <p>Từ khóa <code>range</code> được sử dụng để lặp qua các phần tử của
        mảng, slice, channel, map. Với mảng và slice, index là số nguyên. Với
        map, nó trả về key của cặp key-value. Range trả về một hoặc hai giá trị.
        Nếu chỉ một giá trị được sử dụng ở bên trái biểu thức<code> range</code>,
        nó là giá trị đầu tiên trong bảng sau:</p>
      <table class="table table-bordered table-responsive-md">
        <thead>
          <tr>
            <th>Loại dữ liệu</th>
            <th>Khai báo</th>
            <th>Giá trị đầu tiên</th>
            <th>Giá trị thứ hai (tùy chọn)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Mảng hoặc slice</td>
            <td>a [n]E</td>
            <td>index i int</td>
            <td>a[i] E</td>
          </tr>
          <tr>
            <td>Xâu</td>
            <td>s string</td>
            <td>index i int</td>
            <td>rune int</td>
          </tr>
          <tr>
            <td>Map</td>
            <td>m map[K]V</td>
            <td>key k K</td>
            <td>value m[k] V</td>
          </tr>
          <tr>
            <td>Channel</td>
            <td>c chan E</td>
            <td>Phần tử e E</td>
            <td>none</td>
          </tr>
        </tbody>
      </table>
      <div class="source-file">rangedemo.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

func rangeArray() {
	numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}
	for i, e := range numbers {
		fmt.Println("Slice item", i, "is", e)
	}
}

func rangeMap() {
	countryCapitalMap := map[string]string{
		"France": "Paris",
		"Italy":  "Rome",
		"Japan":  "Tokyo",
	}
	for country, capital := range countryCapitalMap {
		fmt.Println("Capital of", country, "is", capital)
	}
}

func rangeString() {
	s := "Tuấn"
	for _, c := range s {
		fmt.Println(c)
		fmt.Printf("%c\n", c)
	}
}

func rangeChannel() {
	ch := make(chan int)
	go func() {
		ch &lt;- 5
		ch &lt;- 6
		ch &lt;- 7
		close(ch)
	}()
	for n := range ch {
		fmt.Println(n)
	}
}

func main() {
	rangeArray()
	rangeMap()
	rangeString()
	rangeChannel()
}</code></pre>
      <h5>Hàm len</h5>
      <p>Hàm <code>len()</code> trả về độ dài của v, tùy theo kiểu dữ liệu của
        nó.</p>
      <pre>func len(v Type) int</pre>
      <ul>
        <li>Mảng: số phần tử trong mảng</li>
        <li>Pointer đến mảng: Số phần tử trong <code>*v</code></li>
        <li>Slice hoặc map: Số phần tử trong <code>v</code></li>
        <li>String: Số byte</li>
        <li>Channel: Số phần tử đang đợi (chưa đọc) </li>
      </ul>
      <h3>Loại dữ liệu cơ bản</h3>
      <ul>
        <li>Số
          <ul>
            <li>Số nguyên
              <ul>
                <li>Kiểu <code>rune</code> tương đương <code>int32</code></li>
              </ul>
            </li>
            <li>Số dấu phảy động</li>
            <li>Số phức</li>
          </ul>
        </li>
        <li><code>string</code>
          <ul>
            <li>Sử dụng package <code>strings</code> (<code>strings.Join</code>)</li>
            <li>Convert giữa string và số bằng package <code>strconv</code> (<code>strconv.Itoa</code>,
              <code>strconv.Atoi</code>)</li>
          </ul>
        </li>
        <li><code>bool</code></li>
      </ul>
      <h3>Array, slice</h3>
      <p>Array thì có độ dài cố định, ít khi sử dụng trực tiếp. Slice có thể
        tăng hoặc giảm kích thước.</p>
      <p>Để thêm phần tử vào slice, sử dụng hàm <code>append()</code>.</p>
      <p>Hàm <code>cap()</code>:</p>
      <p>Hàm <code>copy()</code>:</p>
      <p>Hàm <code>len()</code>: trả về số phần tử của mảng hoặc slice</p>
      <p>Hàm <code>make()</code>:</p>
      <p>Để xóa phần tử khỏi mảng, sử dụng hàm ?</p>
      <div class="source-file">array_demo.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

// Khai báo []int (không để kích thước) sẽ bị lỗi
func printArray(a [3]int) {
	for _, v := range a {
		fmt.Println(v)
	}
}

func main() {
	var a1 [3]int = [3]int{1, 2, 3}

	// Sử dụng dấu ba chấm thì không cần chỉ định độ dài
	a2 := [...]int{
		1,
		2,
		3, // phải có dấu phảy ở cuối khi khai báo trên nhiều dòng
	}
	printArray(a1)
	printArray(a2)
}</code></pre>
      <div class="source-file">slice_demo.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

func printSlice(a []int) {
	for _, v := range a {
		fmt.Println(v)
	}
}

func main() {
	var a1 []int = []int{1, 2, 3}

	// Sử dụng dấu ba chấm thì không cần chỉ định độ dài
	a2 := []int{
		1,
		2,
		3, // phải có dấu phảy ở cuối khi khai báo trên nhiều dòng
	}
	printSlice(a1)
	printSlice(a2)

	var runes []rune
	for _, r := range "Hello, BF" {
		runes = append(runes, r)
	}
	fmt.Printf("%q\n", runes) // "['H'' e'' l'' l'' o'' ,'''' B'' F']"
}</code></pre>
      <h3>Map </h3>
      <p>Để xóa phần tử khỏi map thì sử dụng hàm <code>delete()</code>.</p>
      <p>Sử dụng hàm <code>make()</code> để khởi tạo map.</p>
      <div class="source-file">map_demo.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

func main() {
	// Khai báo luôn
	ages1 := map[string]int{
		"alice":   31,
		"charlie": 34,
	}
	for person, age := range ages1 {
		fmt.Println(person, ": ", age)
	}

	// Hoặc phải có hàm make
	ages2 := make(map[string]int)
	ages2["alice"] = 31
	ages2["charlie"] = 34

	delete(ages2, "alice")
}</code></pre>
      <h3>Struct</h3>
      <div class="source-file">struct_demo.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"strconv"
	"time"
)

type Employee struct {
	ID        int
	Name      string
	Address   string
	DoB       time.Time
	Position  string
	Salary    int
	ManagerID int
}

func (e Employee) GetInfo() string {
	return "ID: " + strconv.Itoa(e.ID) + ", Name: " + e.Name
}

func main() {
	dilbert := Employee{
		ID:   1,
		Name: "Dilbert",
	}
	dilbert.Salary = 5000
	fmt.Println(dilbert.GetInfo())
}</code></pre>
      <p>Có thể sử dụng phương thức với struct.</p>
      <p>Struct có thể được embed để kế thừa.</p>
      <h3>Interface</h3>
      <div class="source-file">interface_demo.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

type Triangle struct {
	width  float64
	height float64
}

type Rectangle struct {
	width  float64
	height float64
}

type Circle struct {
	radius float64
}

func (t Triangle) GetArea() float64 {
	return t.width * t.height / 2
}

func (r Rectangle) GetArea() float64 {
	return r.width * r.height
}

type Area interface {
	GetArea(p []byte) (n int, err error)
}

// ----------------------------------------------

type Human struct {
	name  string
	age   int
	phone string
}

type Student struct {
	Human
	school string
	loan   float32
}

type Employee struct {
	Human
	company string
	salary  float32
}

// Interface Men sẽ được implement bởi Human, Student, Employee
type Men interface {
	SayHi()
	Sing(lyrics string)
}

// Bạn phải implement các phương thức như sau
// nếu không khi gán sẽ bị lỗi compile
func (h Human) SayHi() {
	fmt.Printf("Xin chào, tôi là %s. Bạn có thể gọi tôi theo số điện thoại %s\n", h.name, h.phone)
}

func (h Human) Sing(lyrics string) {
	fmt.Println("La la la la...", lyrics)
}

func (e Employee) SayHi() {
	fmt.Printf("Xin chào, tôi là %s. Tôi làm việc ở %s\n",
		e.name,
		e.company)
}

func main() {
	mike := Student{Human{"Mike", 25, "222-222-XXX"}, "MIT", 0.00}
	paul := Student{Human{"Paul", 25, "222-222-XXX"}, "Harvard", 100}
	sam := Employee{Human{"Sam", 25, "222-222-XXX"}, "Golang Inc.", 1000}
	tom := Employee{Human{"Tom", 25, "222-222-XXX"}, "Things Ltd.", 5000}

	var men Men

	// men có thể chứa Student
	men = mike
	fmt.Println("Đây là Mike, một sinh viên")
	men.SayHi()
	men.Sing("November rain")

	// men cũng có thể chứa Employee
	men = tom
	fmt.Println("Đây là Tom, một nhân viên")
	men.SayHi()
	men.Sing("Bé bé bồng bông")

	arr := [...]Men{
		paul,
		sam,
		mike,
	}
	for _, e := range arr {
		e.SayHi()
	}
}</code></pre>
      <h3>Datetime</h3>
      <p>Sửa dụng package <code>time</code>.</p>
      <div class="source-file">duration.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"log"
	"time"
)

func track() time.Time {
	return time.Now()
}

func duration(msg string, start time.Time) {
	log.Printf("%v: %v\n", msg, time.Since(start))
}

func foo() {
	defer duration("foo", track())
	time.Sleep(3 * time.Second)
	log.Println("Thực hiện xong hàm")
}

func main() {
	foo()
}</code></pre>
      <h3>Xử lý file</h3>
      <p>Để đọc và ghi file, đơn giản nhất là sử dụng package <code>io/ioutil</code>
        và các hàm <code>ReadFile()</code>, <code>WriteFile()</code>.</p>
      <p>Cấu trúc các hàm là:</p>
      <pre>func ioutil.ReadFile(filename string) ([]byte, error)
func ioutil.WriteFile(filename string, data []byte, perm fs.FileMode) error</pre>
      <div class="note">Chú ý: do đầu vào và đầu ra đều là mảng <code>byte</code>
        nên chúng ta phải convert về <code>string</code>.</div>
      <div class="source-file">write_file.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"io/ioutil"
	"log"
)

func main() {
	s := "Nguyễn Anh Tuấn"
	data := []byte(s)
	filename := "data.txt"
	// perm := 0644
	err := ioutil.WriteFile(filename, data, 0644)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("Done")
}</code></pre>
      <div class="source-file">read_file.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	data, _ := ioutil.ReadFile("data.txt")
	s := string(data)
	fmt.Println(data)
	fmt.Println(s)
}</code></pre>
      <h3>JSON</h3>
      <p>Sử dụng package <code>encoding/json</code>, hàm <code>Marshal()</code>
        và <code>Unmarshal()</code>.</p>
      <p>Các trường không viết hoa sẽ không được output.</p>
      <div class="source-file">json_demo.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"encoding/json"
	"fmt"
)

type User struct {
	Id   int
	Name string
	Job  string
	// Tên trường mà bắt đầu bằng chữ thường
	// sẽ không hiển thị ở JSON output
	desc string
}

func outputJson() {
	u1 := User{1, "John Doe", "gardener", "Sẽ không hiển thị ở JSON"}
	data, _ := json.Marshal(u1)
	fmt.Println(string(data))
}

func parseJson() {
	s := `{
        "Id" : 1,
        "Name": "John Doe",
        "Job": "gardener"
    }`
	data := []byte(s)
	var u2 User
	json.Unmarshal(data, &amp;u2)
	fmt.Println(u2.Name, u2.Job)
}

func main() {
	outputJson()
	parseJson()
}</code></pre>
      <h3>Format</h3>
      <p>Hàm <code>fmt.Printf()</code>, <code>fmt.Println()</code>, <code>fmt.Sscanf()</code>,...
        có <em>verb</em>:</p>
      <table class="table table-bordered table-responsive-md">
        <tbody>
          <tr>
            <td><code>%d</code></td>
            <td>Số nguyên cơ số 10 (decimal)</td>
          </tr>
          <tr>
            <td><code>%x</code></td>
            <td>Số nguyên cơ số 16 (hexa)</td>
          </tr>
          <tr>
            <td><code>%o</code></td>
            <td>Số nguyên cơ số 8 (octal)</td>
          </tr>
          <tr>
            <td><code>%b</code></td>
            <td>Số nguyên nhị phân (binary)</td>
          </tr>
          <tr>
            <td><code>%f</code>, <code>%g</code>, <code>%e</code></td>
            <td>Số dấu phảy động</td>
          </tr>
          <tr>
            <td><code>%t</code></td>
            <td><code>true</code> hoặc <code>false</code></td>
          </tr>
          <tr>
            <td><code>%c</code></td>
            <td>Mã Unicode</td>
          </tr>
          <tr>
            <td><code>%s</code></td>
            <td>Xâu</td>
          </tr>
          <tr>
            <td><code>%q</code></td>
            <td>quoted string "abc" hoặc rune 'c'</td>
          </tr>
          <tr>
            <td><code>%v</code></td>
            <td>Bất kỳ giá trị nào ở format dạng tự nhiên</td>
          </tr>
          <tr>
            <td><code>%T</code></td>
            <td>Kiểu của giá trị</td>
          </tr>
          <tr>
            <td><code>%%</code></td>
            <td>Ký tự <code>%</code></td>
          </tr>
        </tbody>
      </table>
      <div class="source-file">hex_to_rgb.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"strings"
)

func hexToRgb(hex string) {
	var r, g, b int
	patterns := "#" + strings.Repeat("%02x", 3)
	_, err := fmt.Sscanf(hex, patterns, &amp;r, &amp;g, &amp;b)
	fmt.Println(hex, err, r, g, b)
}

func main() {
	hexArr := []string{
		"#112233",
		"#123",
		"#000233",
		"#023",
		"invalid",
		"#abcd",
		"#-12",
	}
	for _, hex := range hexArr {
		hexToRgb(hex)
	}
}</code></pre>
      <h3>Web server</h3>
      <p>Tạo một HTTP server đơn giản.</p>
      <div class="source-file">simple_server.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
)

func HelloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello World")
}

func main() {
	port := 8080
	http.HandleFunc("/", HelloHandler)
	log.Fatal(http.ListenAndServe(":"+strconv.Itoa(port), nil))
}</code></pre>
      <p>Start server:</p>
      <pre>go run simple_server.go</pre>
      <p>Truy cập địa chỉ <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>
        để kiểm tra.</p>
      <p>Mục tiêu: Tạo REST API.</p>
      <div class="source-file">rest_api.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"log"
	"net/http"
)

type Person struct {
	Name string
	Age  int
}

func ServeHTTP(w http.ResponseWriter, r *http.Request) {
	/*
		// Declare a new Person struct.
		var p Person

		// Try to decode the request body into the struct. If there is an error,
		// respond to the client with the error message and a 400 status code.
		err := json.NewDecoder(r.Body).Decode(&amp;p)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
	*/

	var status int
	var data string
	switch r.Method {

	case "GET":
		status = http.StatusOK
		data = `{"message": "get called"}`
	case "POST":
		status = http.StatusCreated
		data = `{"message": "post called"}`
	case "PUT":
		status = http.StatusAccepted
		data = `{"message": "put called"}`
	case "DELETE":
		status = http.StatusOK
		data = `{"message": "delete called"}`
	default:
		status = http.StatusNotFound
		data = `{"message": "not found"}`
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	fmt.Fprintf(w, data)
	// json.NewEncoder(w).Encode(object)
}

func main() {
	http.HandleFunc("/", ServeHTTP)
	log.Fatal(http.ListenAndServe(":8080", nil))
}</code></pre>
      <p>Trên mạng hay sử dụng thư viện:</p>
      <p><a href="https://github.com/gorilla/mux" target="_blank">gorilla/mux: A
          powerful HTTP router and URL matcher for building Go web servers with
          🦍</a></p>
      <p>Tuy nhiên, tôi chỉ dùng Go để tạo các API riêng lẻ, đơn giản, cần tốc
        độ cao. Hệ thống web to vẫn sử dụng Laravel.</p>
      <p><a href="https://grpc.io/" target="_blank">gRPC</a></p>
      <h3>Pointer</h3>
      <p>Một pointer chứa địa chỉ vùng nhớ của một giá trị (giống ngôn ngữ C).
        Giá trị zero của một pointer là <code>nil</code>.</p>
      <p>Pointer rất tiện lợi khi chúng ta copy các cấu trúc lớn hoặc khi chúng
        ta muốn sửa dữ liệu trong một hàm khác.</p>
      <h4>Ký tự * và &amp;</h4>
      <div class="note">Chú ý: Chúng ta cần phân biệt lúc nào sử dụng ký tự <code>*</code>,
        lúc nào sử dụng ký tự <code>&amp;</code></div>
      <p>Giả sử chúng ta có đoạn code:</p>
      <pre>var pv *int<br>pv = &amp;mysum<br>*pv = 4</pre>
      <p>Ở dòng đầu tiên:</p>
      <pre>var pv *int</pre>
      <p><code>*int</code> là kiểu dữ liệu pointer của số nguyên. Khai báo bằng
        <code>*</code>.</p>
      <p>Dòng thứ hai:</p>
      <pre>pv = &amp;mysum</pre>
      <p>Lấy địa chỉ bằng <code>&amp;</code>.</p>
      <p>Dòng thứ ba:</p>
      <pre>*pv = 4</pre>
      <p>Lúc này, ký tự <code>*</code> lại trỏ tới giá trị mà pointer trỏ tới.</p>
      <h4>Pointer đơn giản</h4>
      <div class="source-file">pointer_simple.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

func main() {
	// Khai báo một biến nào đó
	var count int = 4
	fmt.Println(count)

	// Thử thay đổi giá trị biến count
	// bằng biến khác (không được)
	var temp int = count
	temp = 5
	fmt.Println(temp)
	fmt.Println(count) // count vẫn là 4

	// Thử thay đổi giá trị biến count
	// bằng con trỏ (được)
	var pv = &amp;count
	fmt.Println(pv)
	*pv = 3
	fmt.Println(pv) // địa chỉ vùng nhớ không thay đổi
	fmt.Println(*pv)
	fmt.Println(count) // count đã thay đổi là 3

	pv2 := &amp;count
	*pv2 = 2
	fmt.Println(pv2)   // giống địa chỉ vùng nhớ của pv
	fmt.Println(count) // count đã thay đổi là 2
}</code></pre>
      <p>Chạy thử và chúng ta được kết quả như sau:</p>
      <pre class="output">$ go run pointer_simple.go
4
5
4
0xc0000be038
0xc0000be038
3
3
0xc0000be038
2</pre>
      <h4>Thay đổi giá trị</h4>
      <p>Pointer có thể được sử dụng để thay đổi biến ngoài phạm vi hàm mà nó
        định nghĩa. Mặc định, một hàm trong Go sẽ truyền tham số theo giá trị.</p>
      <div class="source-file">pointer_modify.go</div>
      <pre class="code-block"><code class="go">package main

import "fmt"

type User struct {
	Name string
}

func modifyScalarTypeByValue(n int) {
	n = 11
}

func modifyScalarTypeByPointer(pv *int) {
	*pv = 11
}

func modifyStructTypeByValue(u User) {
	u.Name = "Jane"
}

func modifyStructTypeByPointer(pu *User) {
	// Chú ý, không dùng *pu.Name (bị lỗi compile)
	// pu.Name tương đương với (*pu).Name
	// pu.Name = "Jane"
	(*pu).Name = "Jane"
}

func main() {
	count := 10
	modifyScalarTypeByValue(count)
	fmt.Println(count) // giá trị vẫn giữ nguyên là 10
	modifyScalarTypeByPointer(&amp;count)
	fmt.Println(count) // giá trị đã thay đổi là 11

	u := User{"John"}
	modifyStructTypeByValue(u)
	fmt.Println(u.Name)
	modifyStructTypeByPointer(&amp;u)
	fmt.Println(u.Name)
}</code></pre>
      <p>Chạy chương trình:</p>
      <pre class="output">$ go run pointer_modify.go
10
11
John
Jane</pre>
      <h4>Từ khóa new</h4>
      <p>Từ khóa <code>new</code> có tham số là một kiểu dữ liệu, allocate đủ
        bộ nhớ để vừa một giá trị của kiểu đó và trả về con trỏ tới đó.</p>
      <div class="source-file">pointer_new.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"reflect"
)

type User struct {
	Name string
}

func main() {
	pu := new(User)
	fmt.Println(pu)
	fmt.Println(reflect.TypeOf(pu))

	pu.Name = "John"
	fmt.Println(pu)
}</code></pre>
      <p>Chạy chương trình:</p>
      <pre class="output">$ go run pointer_new.go
&amp;{}
*main.User
&amp;{John}</pre>
      <h3>Build</h3>
      <p>Chúng ta build ra file binary để có thể chạy nhanh nhất có thể. Tuy
        nhiên, các file binary này không thể chạy trên tất cả các mỗi trường
        khác nhau (Windows, Linux, Mac).</p>
      <p>Sử dụng công cụ go build, biến môi trường, build tag, bạn có thể chỉ
        định OS và architecture của file binary.</p>
      <h4>GOOS và GOARCH</h4>
      <p>Các GOOS và GOARCH hỗ trợ</p>
      <p>Sử dụng lệnh:</p>
      <pre>go tool dist list</pre>
      <p>Kết quả trên máy tôi:</p>
      <pre class="output">aix/ppc64
android/386
android/amd64
android/arm
android/arm64
darwin/amd64
darwin/arm64
dragonfly/amd64
freebsd/386
freebsd/amd64
freebsd/arm
freebsd/arm64
illumos/amd64
ios/amd64
ios/arm64
js/wasm
linux/386
linux/amd64
linux/arm
linux/arm64
linux/mips
linux/mips64
linux/mips64le
linux/mipsle
linux/ppc64
linux/ppc64le
linux/riscv64
linux/s390x
netbsd/386
netbsd/amd64
netbsd/arm
netbsd/arm64
openbsd/386
openbsd/amd64
openbsd/arm
openbsd/arm64
openbsd/mips64
plan9/386
plan9/amd64
plan9/arm
solaris/amd64
windows/386
windows/amd64
windows/arm</pre>
      <p>Để xem máy bạn đang sử dụng thuộc loại nào, sử dụng lệnh:</p>
      <pre>go env GOOS GOARCH</pre>
      <p>Kết quả trên máy Windows của tôi:</p>
      <pre class="output">windows
amd64</pre>
      <p>Nếu máy bạn không cài Go, trên Windows, sử dụng câu lệnh:</p>
      <pre>set</pre>
      <p>Sau đó tìm đến giá trị <code>PROCESSOR_ARCHITECTURE</code>.</p>
      <p>Hoặc thực hiện lệnh:</p>
      <pre>echo %PROCESSOR_ARCHITECTURE%</pre>
      <p>Trên máy Windows của tôi, giá trị là AMD64.</p>
      <p>Trên Linux, thực hiện lệnh:</p>
      <pre>uname -m</pre>
      <p>Các giá trị có thể có là <code>x86_64</code>, <code>i686</code>, <code>arm</code>,
        <code>aarch64</code>.</p>
      <p>Bảng tương ứng với GOARCH:</p>
      <table class="table table-bordered">
        <tbody>
          <tr>
            <td><code>i386</code></td>
            <td><code>386</code></td>
          </tr>
          <tr>
            <td><code>i686</code></td>
            <td><code>386</code></td>
          </tr>
          <tr>
            <td><code>x86_64</code></td>
            <td><code>amd64</code></td>
          </tr>
          <tr>
            <td><code>arm</code></td>
            <td><code>arm</code> hoặc <code>arm64</code></td>
          </tr>
        </tbody>
      </table>
      <p>Kết quả trên máy CentOS ở công ty tôi là <code>x86_64</code>, tương
        đương với <code>linux/amd64</code>:</p>
      <p>Kết quả trên máy Ubuntu ở nhà tôi là: </p>
      <p>amd là chip ?. arm là chip Intel.</p>
      <h4>Chương trình mẫu</h4>
      <p>Không phụ thuộc nền tảng. Sử dụng hàm <code>filepath.Join()</code>. Ký
        tự ngăn cách trên Windows là <code>\</code>, trên Linux là <code>/</code>.</p>
      <div class="source-file">cross_platform.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"path/filepath"
)

func main() {
	s := filepath.Join("a", "b", "c")
	fmt.Println(s)
}</code></pre>
      <h4>Thực hiện build </h4>
      <p>Mặc định lệnh <code>go build</code> sẽ build ra file thực thi tương
        ứng với môi trường của máy hiện tại.</p>
      <p>Từ máy Windows, để build ra file chạy trên Linux:</p>
      <pre>set GOOS=linux<br>set GOARCH=amd64<br>go build -o cross_platform_linux_amd64 cross_platform.go</pre>
      <p>Từ máy Linux, để build ra file chạy trên Windows:</p>
      <pre>GOOS=windows go build cross_platform.go
</pre>
      <p>Chúng ta có thể chỉ định tên file đầu ra có dạng <code>filename_GOOS_GOARCH</code>
        bằng tham số <code>-o</code>.</p>
      <p>Giờ chúng ta có thể copy các file đã build này lên các môi trường khác
        nhau và thực thi.</p>
      <h3>Câu lệnh go</h3>
      <p><code>build</code>: Tạo file binary</p>
      <p>clean:</p>
      <p>doc:</p>
      <p><code>env</code>: Liệt kê các biến môi trường</p>
      <p>fmt:</p>
      <p><code>get</code>: Cài đặt thư viện</p>
      <p>install:</p>
      <p>list:</p>
      <p><code>run</code>: Chạy chương trình</p>
      <p>test:</p>
      <p><code>version</code>: Hiển thị phiên bản</p>
      <p>vet:</p>
      <h3>Package</h3>
      <p>Để chạy phải để trong package <code>main</code>, hàm <code>main</code>.</p>
      <p>Package hỗ trợ modularity, encapsulation, separation, reuse.</p>
      <p>Convention: Tên file viết liền?</p>
      <p>Tên file nên đặt chữ thường hết, viết liền, có thể có gạch dưới để ngăn
        cách, không sử dụng gạch ngang.</p>
      <p>Import local package?</p>
      <p>Chữ cái đầu tiên viết hoa thì được export.</p>
      <p>Chữ cái đầu tiên viết thường thì không thể truy cập.</p>
      <p>Tool <code>goimports</code>.</p>
      <p>Hàm <code>init()</code> tự động thực hiện theo thứ tự khai báo.</p>
      <p>Khi source code nhiều thì cần chia ra cho dễ maintain.</p>
      <h3>Regex</h3>
      <p>Biểu thức chính quy</p>
      <h3>Testing</h3>
      <p>Lệnh <code>go test</code>.</p>
      <p>Các file có dạng <code>*_test.go</code>.</p>
      <p>Hàm có dạng:</p>
      <pre class="code-block"><code class="go">import "testing"<br><br>func TestName(t *testing.T) {<br>}</code></pre>
      <p> Bạn phải init project trước:</p>
      <pre>go mod init test_demo</pre>
      <p>Thực hiện test:</p>
      <pre>go test</pre>
      <p>Kết quả:</p>
      <pre class="output">PASS
ok      test_demo       0.090s</pre>
      <h3>Logging</h3>
      <p>Lưu log.</p>
      <p>Sử dụng package có sẵn <code>log</code> luôn.</p>
      <p>Log ra file thế nào?</p>
      <h3>Goroutine và channel</h3>
      <p>Xử lý đồng thời trong Go là khả năng của các hàm chạy độc lập với nhau.
        Goroutine là các hàm chạy đồng thời.</p>
      <p>Goroutine mới được tạo bằng biểu thức <code>go</code>.</p>
      <pre>sum()<br>go sum()</pre>
      <p>Dòng đầu tiên là một lời gọi hàm bình thường. Hàm <code>sum()</code>
        sẽ được thực hiện đồng bộ và chờ cho nó kết thúc.</p>
      <p>Dòng thứ hai một goroutine sẽ thực hiện hàm <code>sum()</code> bất
        đồng bộ và không chờ cho nó kết thúc. Từ khóa <code>go</code> làm cho
        lời gọi hàm trả về ngay lập tức, trong khi hàm sẽ được chạy ở background
        như là một goroutine và phần còn lại của chương trình tiếp tục thực thi.</p>
      <p>Hàm <code>main</code> của tất cả các chương trình Go cũng được bắt đầu
        sử dụng một goroutine.</p>
      <p>Sử dụng goroutine thường giúp tăng hiệu năng gấp 4 lần?</p>
      <h4>Goroutine đơn giản</h4>
      <div class="source-file">goroutine_simple.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"time"
)

func getRemoteResource(msg string) {
	time.Sleep(3 * time.Second)
	fmt.Println("Finish goroutine", msg)
}

func main() {
	start := time.Now()

	go getRemoteResource("1")
	go getRemoteResource("2")

	// Goroutine main phải chờ các goroutine khác thực hiện xong
	// hoặc nó phải thực hiện lâu nhất
	// nếu không, toàn bộ chương trình sẽ kết thúc luôn
	// trước khi các goroutine kết thúc
	time.Sleep(5 * time.Second)

	fmt.Printf("Finish main after %v\n", time.Since(start))
}</code></pre>
      <p>Thực thi:</p>
      <pre class="output">$ go run goroutine_simple.go
Finish goroutine 2
Finish goroutine 1
Finish main after 5.0000409s</pre>
      <p>Ở chương trình trên, chúng ta thực hiện hai hàm goroutine con, mỗi hàm
        thực hiện trong 3 giây. Ngoài ra, goroutine main cũng thực hiện trong 5
        giây. Tuy nhiên, tổng thời gian thực thi của cả chương trình không phải
        là 3+3+5 = 11 giây mà chỉ là 5 giây (của goroutine lâu nhất).</p>
      <h4>Chờ các goroutine thực thi xong</h4>
      <p>Kiểu dữ liệu <code>sync.WaitGroup</code> được sử dụng để chờ tất cả
        các goroutine được khởi động từ hàm main kết thúc. Nó sử dụng một
        counter chỉ định số goroutine.</p>
      <p>Phương thức <code>Add()</code> để thêm counter vào WaitGroup.</p>
      <p>Phương thức <code>Done()</code> được lập lịch sử dụng biểu thức <code>defer</code>
        ở các goroutine con, giảm counter.</p>
      <p>Phương thức <code>Wait()</code> ngăn sự thực thi của chương trình cho
        đến khi counter của WaitGroup bằng 0.</p>
      <div class="source-file">goroutine_wait.go</div>
      <pre class="code-block"><code class="go">package main

import (
	"fmt"
	"sync"
	"time"
)

// Khai báo toàn cục
var wg sync.WaitGroup

func getRemoteResource(msg string) {
	// Chờ cho đến khi hàm thực hiện xong thì đánh dấu là Done
	defer wg.Done()

	time.Sleep(3 * time.Second)
	fmt.Println("Finish goroutine", msg)
}

func main() {
	start := time.Now()

	// Thêm 2 goroutine
	wg.Add(2)

	go getRemoteResource("1")
	go getRemoteResource("2")

	// Chờ cho các goroutine thực thi xong
	wg.Wait()

	fmt.Printf("Finish main after %v\n", time.Since(start))
}</code></pre>
      <p>Thực thi:</p>
      <pre class="output">go run goroutine_wait.go
Finish goroutine 2
Finish goroutine 1
Finish main after 3.0021864s</pre>
      <h4>Lấy giá trị từ goroutine<br>
      </h4>
      <p>Cách tự nhiên nhất để lấy một giá trị từ một goroutine là channel.
        Channel là các pipe mà kết nối các goroutine đồng thời. Bạn có thể gửi
        các giá trị vào channel từ một goroutine và lấy các giá trị đó từ
        goroutine khác hoặc trong một hàm đồng bộ.</p>
      <p>goroutine_get_value.go</p>
      <p>x</p>
      <p>Play và pause goroutine</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p><br>
      </p>
      <p>Chú ý xử lý biến dùng chung (atomic, mutex, channel).</p>
      <p><br>
      </p>
      <h3>Channel</h3>
      <h4>Sử dụng channel</h4>
      <p>Channel là tính năng cho phép 2 goroutine giao tiếp / trao đổi dữ liệu
        với nhau.</p>
      <p>channel_1.go</p>
      <p>Đoạn code trên sẽ in dòng chữ "ping" cho đến khi người dùng nhấn phím
        Enter.</p>
      <p>Chúng ta sử dụng hai goroutine là <code>pinger()</code> và <code>printer()</code>
        và một channel là <code>c</code>. Về cơ bản thì goroutine là các luồng
        chương trình chạy xuyên suốt, channel có thể coi như là các "ống" truyền
        dữ liệu qua lại giữa các chương trình đó.</p>
      <figure> <img src="images/goroutine%20-%20channel.png" alt=""> </figure>
      <p>Một channel trong Go chỉ là một biến thường, chỉ khác là các goroutine
        có thể đọc và ghi dữ liệu vào đó.</p>
      <p>Để khai báo một channel thì chúng ta thêm từ khóa <code>chan</code>
        vào phía trước kiểu dữ liệu và dùng hàm <code>make()</code>:</p>
      <pre>c := make(chan &lt;kiểu dữ liệu&gt;)</pre>
      <p>Để đẩy dữ liệu vào channel, chúng ta để toán tử <code>&lt;-</code> ở
        bên phải biến:</p>
      <pre>c &lt;- "ping"</pre>
      <p>Để lấy dữ liệu từ channel, chúng ta để toán tử <code>&lt;-</code> ở
        bên trái biến (và viết liền):</p>
      <pre>msg := &lt;-c     </pre>
      <h4>Đồng bộ với channel</h4>
      <p>Việc sử dụng channel cho phép đồng bộ hóa dữ liệu giữa các goroutine
        bởi vì khi một goroutine truyền dữ liệu vào channel thì goroutine đó sẽ
        dừng chương trình của nó và đợi cho đến khi có một goroutine khác lấy dữ
        liệu ra khỏi channel thì mới tiếp tục.</p>
      <h4>Điều hướng channel</h4>
      <p>Chúng ta có thể quy định một goroutine chỉ được phép đọc hoặc ghi dữ
        liệu vào channel.</p>
      <pre>func handleSend(c chan&lt;- string) {<br>    // Chỉ được phép ghi dữ liệu vào channel c trong goroutine này<br>}<br>
func handleReceive(c &lt;-chan string) {<br>    // Chỉ được phép đọc dữ liệu từ channel c trong goroutine này<br>}
</pre>
      <ul>
        <li><code>chan&lt;-</code>: chỉ ghi</li>
        <li><code>&lt;-chan</code>: chỉ đọc</li>
        <li><code>chan</code>: cả đọc và ghi</li>
      </ul>
      <h4>Lệnh select</h4>
      <p>Lệnh <code>select</code> trong Go có chức năng gần giống như lệnh <code>switch</code>,
        chỉ khác là <code>select</code> được dùng với biến channel.</p>
      <p>select.go</p>
      <p><br>
      </p>
      <p><br>
      </p>
      <h4>Buffered channel</h4>
      <p>Các goroutine khi truyền dữ liệu vào channel thì phải có một goroutine
        khác lấy dữ liệu ra và ngược lại, nếu không các goroutine sẽ đi vào
        trạng thái chờ.</p>
      <p>Tuy nhiên, chúng ta có thể cho phép các goroutine không chờ nữa bằng
        cách dùng các buffered channel.</p>
      <p>channel_buffered.go</p>
      <p><br>
      </p>
      <p>Unbuffered channel</p>
      <p><br>
      </p>
      <h3>Panic và recover</h3>
      <p>TODO</p>
      <h3>Redis</h3>
      <p>Thao tác với Redis.</p>
      <h3>MySQL</h3>
      <p>Thao tác với MySQL.</p>
      <h3>Tham khảo</h3>
      <p><a href="https://en.wikipedia.org/wiki/Go_%28programming_language%29" target="_blank">Go
          (programming language) - Wikipedia</a></p>
      <p><a href="https://golang.org/" target="_blank">The Go Programming
          Language</a></p>
      <p><a href="https://github.com/avelino/awesome-go" target="_blank">avelino/awesome-go:
          A curated list of awesome Go frameworks, libraries and software</a></p>
      <p><a href="https://zetcode.com/all/#go" target="_blank">ZetCode all
          tutorials</a> (nhiều code ví dụ hay)</p>
      <p><a href="https://viblo.asia/tags/golang" target="_blank">golang - Viblo</a></p>
      <p><a href="https://github.com/uber-go/guide" target="_blank">uber-go/guide:
          The Uber Go Style Guide</a></p>
      <p>---</p>
      <p>Học cấu trúc dữ liệu và giải thuật để luyện tư duy (tách post khác).</p>
      <p>Go data structures and algorithms</p>
      <p><a href="https://www.golangprograms.com/data-structure-and-algorithms.html"

          target="_blank">The fundamentals of the Go programming language from
          the perspective of data structures and algorithms. -
          golangprograms.com</a></p>
      <p><a href="https://en.wikipedia.org/wiki/String-searching_algorithm" target="_blank">String-searching
          algorithm - Wikipedia</a> </p>
      <p><a href="https://en.m.wikipedia.org/wiki/List_of_data_structures" target="_blank">List
          of data structures - Wikipedia</a> </p>
    </article>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.7.2/build/styles/github-gist.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.7.2/build/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.7.2/build/languages/go.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="../../js/docs.js"></script>
  </body>
</html>
